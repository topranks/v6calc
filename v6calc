#!/usr/bin/python3

import argparse
import ipaddress
from num2words import num2words
from math import log2
import sys

def main():
    """Prints out details of IPv6 subnet from address/network"""
    parser = argparse.ArgumentParser()
    parser.add_argument('-c', '--count', help='If specified output will also show count of IPs and networks in the range', action='store_true')
    parser.add_argument('ip_with_prefixlen', help='IPv6 address including prefix length, i.e. 2000::1/3')
    args = parser.parse_args()
    
    try:
        v6_net = ipaddress.ip_network(args.ip_with_prefixlen)
        v6_int = v6_net[0]
    except ValueError:
        try:
            v6_int = ipaddress.ip_interface(args.ip_with_prefixlen)
            v6_net = v6_int.network
        except Exception as e:
            print(f"Cannot parse {args.input_ip} - make sure it is an IPv6 with prefix - {e}")
            sys.exit(1)

    print(f"Address:    {v6_int}")
    print(f"Network:    {v6_net}")
    print(f"Last Addr:  {v6_net[-1]}")
    print()

    if not args.count:
        sys.exit(0)

    # tables where we store output for later
    num_table = [get_text_labels(v6_net.num_addresses, "Num Addrs:")]
    size_table = []

    if v6_net.prefixlen < 64:
        netsize = 64
        while netsize > v6_net.prefixlen:
            # Number of nets is 2^(child_prefixlen - parent_prefixlen)
            num_child_nets = 2 ** (netsize - v6_net.prefixlen)
            size_table.append(get_text_labels(num_child_nets, f"Num /{netsize}:"))
            netsize = netsize - 4

    # Get width of longest number description
    width = 0
    for entry in size_table + num_table:
        if len(entry['text_number']) > width:
            width = len(entry['text_number']) + 2

    for table in (num_table, size_table):
        for entry in table:
            text_number = f"{entry['text_number']:<{width}}"
            print(f"{entry['prefix']:<11} {text_number} {entry['log2']:<7} {entry['number']}")
        print()


def get_text_labels(number: int, prefix: str):
    """Returns the text version and log2 equivalent the number"""
    labels = {'number': f"{number:,}", 'prefix': prefix}
    if number < 99999:
        labels['text_number'] = f"{number:,}"
    significant_digits = f"{number:,}".split(",")[0]
    # Pad the significant digits with zero to the same length to get the "closest" big number
    closest_num = significant_digits + ((len(str(number))) - len(significant_digits)) * "0"
    labels['text_number'] = num2words(closest_num)
    labels['log2'] = f"(2^{int(log2(number))})"
    return labels

if __name__=="__main__":
    main()
